--- lib/pixel-mapper.cc
+++ lib/pixel-mapper.cc
@@ -162,6 +162,73 @@ class UArrangementMapper : public PixelMapper {
   int parallel_;
 };
 
+// If we take a long chain of panels and arrange them in a S-shape, so
+// that after half the panels we continue above. This way
+// we have a panel that has double the height but only uses one chain.
+//
+// The SmartMatrix library (see https://github.com/pixelmatix/SmartMatrix)
+// refers to this configuration as SMARTMATRIX_OPTIONS_BOTTOM_TO_TOP_STACKING.
+//
+// A single chain display with four 32x32 panels can then be arranged in this
+// 64x64 display:
+//    [<][<][<][<] }- Raspbery Pi connector
+//
+// can be arranged in this bottom up S-shape
+//    [<][<]
+//    [<][<] }----- Raspberry Pi connector
+//
+class BottomToTopArrangementMapper : public PixelMapper {
+public:
+    BottomToTopArrangementMapper() : parallel_(1) {}
+    
+    virtual const char *GetName() const { return "BottomToTop-mapper"; }
+    
+    virtual bool SetParameters(int chain, int parallel, const char *param) {
+        if (chain < 2) {  // technically, a chain of 2 would work, but somewhat pointless
+            fprintf(stderr, "BottomToTop-mapper: need at least --led-chain=4 for useful folding\n");
+            return false;
+        }
+        if (chain % 2 != 0) {
+            fprintf(stderr, "BottomToTop-mapper: Chain (--led-chain) needs to be divisible by two\n");
+            return false;
+        }
+        parallel_ = parallel;
+        return true;
+    }
+    
+    virtual bool GetSizeMapping(int matrix_width, int matrix_height,
+                                int *visible_width, int *visible_height)
+    const {
+        *visible_width = (matrix_width / 64) * 32;   // Div at 32px boundary
+        *visible_height = 2 * matrix_height;
+        if (matrix_height % parallel_ != 0) {
+            fprintf(stderr, "%s For parallel=%d we would expect the height=%d "
+                    "to be divisible by %d ??\n",
+                    GetName(), parallel_, matrix_height, parallel_);
+            return false;
+        }
+        return true;
+    }
+    
+    virtual void MapVisibleToMatrix(int matrix_width, int matrix_height,
+                                    int x, int y,
+                                    int *matrix_x, int *matrix_y) const {
+        const int panel_height = matrix_height / parallel_;
+        const int visible_width = (matrix_width / 64) * 32;
+        const int slab_height = 2 * panel_height;   // one folded s-shape
+        y %= slab_height;
+        if (y >= panel_height) {
+            x += visible_width;
+            y -= panel_height;
+        }
+        *matrix_x = x;
+        *matrix_y = y;
+    }
+    
+private:
+    int parallel_;
+};
+
 typedef std::map<std::string, PixelMapper*> MapperByName;
 static void RegisterPixelMapperInternal(MapperByName *registry,
                                         PixelMapper *mapper) {
@@ -178,6 +245,7 @@ static MapperByName *CreateMapperMap() {
   // Register all the default PixelMappers here.
   RegisterPixelMapperInternal(result, new RotatePixelMapper());
   RegisterPixelMapperInternal(result, new UArrangementMapper());
+  RegisterPixelMapperInternal(result, new BottomToTopArrangementMapper());
   return result;
 }
 
--- lib/pixel-mapper.cc
+++ lib/pixel-mapper.cc
@@ -179,56 +179,56 @@ class UArrangementMapper : public PixelMapper {
 //
 class BottomToTopArrangementMapper : public PixelMapper {
 public:
-    BottomToTopArrangementMapper() : parallel_(1) {}
-    
-    virtual const char *GetName() const { return "BottomToTop-mapper"; }
-    
-    virtual bool SetParameters(int chain, int parallel, const char *param) {
-        if (chain < 2) {  // technically, a chain of 2 would work, but somewhat pointless
-            fprintf(stderr, "BottomToTop-mapper: need at least --led-chain=4 for useful folding\n");
-            return false;
-        }
-        if (chain % 2 != 0) {
-            fprintf(stderr, "BottomToTop-mapper: Chain (--led-chain) needs to be divisible by two\n");
-            return false;
-        }
-        parallel_ = parallel;
-        return true;
+  BottomToTopArrangementMapper() : parallel_(1) {}
+  
+  virtual const char *GetName() const { return "BottomToTop-mapper"; }
+  
+  virtual bool SetParameters(int chain, int parallel, const char *param) {
+    if (chain < 2) {  // technically, a chain of 2 would work, but somewhat pointless
+      fprintf(stderr, "BottomToTop-mapper: need at least --led-chain=4 for useful folding\n");
+      return false;
     }
-    
-    virtual bool GetSizeMapping(int matrix_width, int matrix_height,
-                                int *visible_width, int *visible_height)
-    const {
-        *visible_width = (matrix_width / 64) * 32;   // Div at 32px boundary
-        *visible_height = 2 * matrix_height;
-        if (matrix_height % parallel_ != 0) {
-            fprintf(stderr, "%s For parallel=%d we would expect the height=%d "
-                    "to be divisible by %d ??\n",
-                    GetName(), parallel_, matrix_height, parallel_);
-            return false;
-        }
-        return true;
+    if (chain % 2 != 0) {
+      fprintf(stderr, "BottomToTop-mapper: Chain (--led-chain) needs to be divisible by two\n");
+      return false;
     }
-    
-    virtual void MapVisibleToMatrix(int matrix_width, int matrix_height,
-                                    int x, int y,
-                                    int *matrix_x, int *matrix_y) const {
-        const int panel_height = matrix_height / parallel_;
-        const int visible_width = (matrix_width / 64) * 32;
-        const int slab_height = 2 * panel_height;   // one folded s-shape
-        y %= slab_height;
-        if (y >= panel_height) {
-            x += visible_width;
-            y -= panel_height;
-        }
-        *matrix_x = x;
-        *matrix_y = y;
+    parallel_ = parallel;
+    return true;
+  }
+  
+  virtual bool GetSizeMapping(int matrix_width, int matrix_height,
+                              int *visible_width, int *visible_height)
+  const {
+    *visible_width = (matrix_width / 64) * 32;   // Div at 32px boundary
+    *visible_height = 2 * matrix_height;
+    if (matrix_height % parallel_ != 0) {
+      fprintf(stderr, "%s For parallel=%d we would expect the height=%d "
+              "to be divisible by %d ??\n",
+              GetName(), parallel_, matrix_height, parallel_);
+      return false;
     }
-    
+    return true;
+  }
+  
+  virtual void MapVisibleToMatrix(int matrix_width, int matrix_height,
+                                  int x, int y,
+                                  int *matrix_x, int *matrix_y) const {
+    const int panel_height = matrix_height / parallel_;
+    const int visible_width = (matrix_width / 64) * 32;
+    const int slab_height = 2 * panel_height;   // one folded s-shape
+    y %= slab_height;
+    if (y >= panel_height) {
+      x += visible_width;
+      y -= panel_height;
+    }
+    *matrix_x = x;
+    *matrix_y = y;
+  }
+  
 private:
-    int parallel_;
+  int parallel_;
 };
-
+  
 typedef std::map<std::string, PixelMapper*> MapperByName;
 static void RegisterPixelMapperInternal(MapperByName *registry,
                                         PixelMapper *mapper) {
