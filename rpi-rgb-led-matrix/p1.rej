--- pixel-mapper.cc
+++ pixel-mapper.cc
@@ -162,6 +162,73 @@ class UArrangementMapper : public PixelMapper {
   int parallel_;
 };
 
+// If we take a long chain of panels and arrange them in a S-shape, so
+// that after half the panels we continue above. This way
+// we have a panel that has double the height but only uses one chain.
+//
+// The SmartMatrix library (see https://github.com/pixelmatix/SmartMatrix)
+// refers to this configuration as SMARTMATRIX_OPTIONS_BOTTOM_TO_TOP_STACKING.
+//
+// A single chain display with four 32x32 panels can then be arranged in this
+// 64x64 display:
+//    [<][<][<][<] }- Raspbery Pi connector
+//
+// can be arranged in this bottom up S-shape
+//    [<][<]
+//    [<][<] }----- Raspberry Pi connector
+//
+class BottomToTopArrangementMapper : public PixelMapper {
+public:
+    BottomToTopArrangementMapper() : parallel_(1) {}
+    
+    virtual const char *GetName() const { return "BottomToTop-mapper"; }
+    
+    virtual bool SetParameters(int chain, int parallel, const char *param) {
+        if (chain < 2) {  // technically, a chain of 2 would work, but somewhat pointless
+            fprintf(stderr, "BottomToTop-mapper: need at least --led-chain=4 for useful folding\n");
+            return false;
+        }
+        if (chain % 2 != 0) {
+            fprintf(stderr, "BottomToTop-mapper: Chain (--led-chain) needs to be divisible by two\n");
+            return false;
+        }
+        parallel_ = parallel;
+        return true;
+    }
+    
+    virtual bool GetSizeMapping(int matrix_width, int matrix_height,
+                                int *visible_width, int *visible_height)
+    const {
+        *visible_width = (matrix_width / 64) * 32;   // Div at 32px boundary
+        *visible_height = 2 * matrix_height;
+        if (matrix_height % parallel_ != 0) {
+            fprintf(stderr, "%s For parallel=%d we would expect the height=%d "
+                    "to be divisible by %d ??\n",
+                    GetName(), parallel_, matrix_height, parallel_);
+            return false;
+        }
+        return true;
+    }
+    
+    virtual void MapVisibleToMatrix(int matrix_width, int matrix_height,
+                                    int x, int y,
+                                    int *matrix_x, int *matrix_y) const {
+        const int panel_height = matrix_height / parallel_;
+        const int visible_width = (matrix_width / 64) * 32;
+        const int slab_height = 2 * panel_height;   // one folded s-shape
+        y %= slab_height;
+        if (y >= panel_height) {
+            x += visible_width;
+            y -= panel_height;
+        }
+        *matrix_x = x;
+        *matrix_y = y;
+    }
+    
+private:
+    int parallel_;
+};
+
 typedef std::map<std::string, PixelMapper*> MapperByName;
 static void RegisterPixelMapperInternal(MapperByName *registry,
                                         PixelMapper *mapper) {
@@ -178,6 +245,7 @@ static MapperByName *CreateMapperMap() {
   // Register all the default PixelMappers here.
   RegisterPixelMapperInternal(result, new RotatePixelMapper());
   RegisterPixelMapperInternal(result, new UArrangementMapper());
+  RegisterPixelMapperInternal(result, new BottomToTopArrangementMapper());
   return result;
 }
 
--- README.md
+++ README.md
@@ -22,7 +22,7 @@ Options:
         --led-multiplexing=<0..6> : Mux type: 0=direct; 1=Stripe; 2=Checkered; 3=Spiral; 4=ZStripe; 5=ZnMirrorZStripe; 6=coreman (Default: 0)
         --led-pixel-mapper        : Semicolon-separated list of pixel-mappers to arrange pixels.
                                     Optional params after a colon e.g. "U-mapper;Rotate:90"
-                                    Available: "Rotate", "U-mapper". Default: ""
+                                    Available: "Rotate", "U-mapper", "BottomToTop-mapper". Default: ""
         --led-pwm-bits=<1..11>    : PWM bits (Default: 11).
         --led-brightness=<percent>: Brightness in percent (Default: 100).
         --led-scan-mode=<0..1>    : 0 = progressive; 1 = interlaced (Default: 0).
@@ -270,6 +270,42 @@ as parameter after a colon:
   ./demo --led-pixel-mapper="Rotate:90"
 ```
 
+#### BottomToTop-mapper
+
+Say you have 4 displays with 32x32 and only a single output
+like with a Raspberry Pi 1 or the Adafruit HAT -- if we chain
+them, we get a display 32 pixel high, (4*32)=128 pixel long. If we arrange
+the boards in a S-shape so that they form a square, we get a logical display
+of 64x64 pixels with the Raspberry Pi is connected at the bottom end of the chain.
+
+<img src="../img/chained-64x64-back-bottom-to-top.jpg" width="400px">
+
+This mapper is especially useful if you are migrating from the 
+[SmartMatrix](https://github.com/pixelmatix/SmartMatrix) library and don't want to
+have to reorient your panels.  SmartMatrix refers to this configuration
+as SMARTMATRIX_OPTIONS_BOTTOM_TO_TOP_STACKING.
+
+```
+So the following chain
+    [<][<][<][<] }- Raspbery Pi connector
+
+is arranged in this U-shape (on its side)
+    [<][<]
+    [<][<] }----- Raspberry Pi connector
+```
+
+Now we need to internally map pixels the pixels so that the 'folded' 128x32
+screen behaves like a 64x64 screen.
+
+There is a pixel-mapper that can help with this "BottomToTop-Arrangement", you choose
+it with `--led-pixel-mapper=BottomToTop-mapper`. So in this particular case,
+
+```
+  ./demo --led-chain=4 --led-pixel-mapper="BottomToTop-mapper"
+```
+
+This mapper should work for more than one chain, but is untested.
+
 #### Combining Mappers
 
 You can chain multiple mappers in the configuration, by separating them
@@ -347,4 +383,4 @@ line option in C++ and Python.
 [git-submodules]: http://git-scm.com/book/en/Git-Tools-Submodules
 [pixelpush]: https://github.com/hzeller/rpi-matrix-pixelpusher
 [pp-vid]: ../img/pixelpusher-vid.jpg
-[otf2bdf]: https://www.math.nmsu.edu/~mleisher/Software/otf2bdf/+[otf2bdf]: https://www.math.nmsu.edu/~mleisher/Software/otf2bdf/
--- README.md
+++ README.md
@@ -289,7 +289,7 @@ as SMARTMATRIX_OPTIONS_BOTTOM_TO_TOP_STACKING.
 So the following chain
     [<][<][<][<] }- Raspbery Pi connector
 
-is arranged in this U-shape (on its side)
+is arranged in this S-shape
     [<][<]
     [<][<] }----- Raspberry Pi connector
 ```
--- pixel-mapper.cc
+++ pixel-mapper.cc
@@ -179,56 +179,56 @@ class UArrangementMapper : public PixelMapper {
 //
 class BottomToTopArrangementMapper : public PixelMapper {
 public:
-    BottomToTopArrangementMapper() : parallel_(1) {}
-    
-    virtual const char *GetName() const { return "BottomToTop-mapper"; }
-    
-    virtual bool SetParameters(int chain, int parallel, const char *param) {
-        if (chain < 2) {  // technically, a chain of 2 would work, but somewhat pointless
-            fprintf(stderr, "BottomToTop-mapper: need at least --led-chain=4 for useful folding\n");
-            return false;
-        }
-        if (chain % 2 != 0) {
-            fprintf(stderr, "BottomToTop-mapper: Chain (--led-chain) needs to be divisible by two\n");
-            return false;
-        }
-        parallel_ = parallel;
-        return true;
+  BottomToTopArrangementMapper() : parallel_(1) {}
+  
+  virtual const char *GetName() const { return "BottomToTop-mapper"; }
+  
+  virtual bool SetParameters(int chain, int parallel, const char *param) {
+    if (chain < 2) {  // technically, a chain of 2 would work, but somewhat pointless
+      fprintf(stderr, "BottomToTop-mapper: need at least --led-chain=4 for useful folding\n");
+      return false;
     }
-    
-    virtual bool GetSizeMapping(int matrix_width, int matrix_height,
-                                int *visible_width, int *visible_height)
-    const {
-        *visible_width = (matrix_width / 64) * 32;   // Div at 32px boundary
-        *visible_height = 2 * matrix_height;
-        if (matrix_height % parallel_ != 0) {
-            fprintf(stderr, "%s For parallel=%d we would expect the height=%d "
-                    "to be divisible by %d ??\n",
-                    GetName(), parallel_, matrix_height, parallel_);
-            return false;
-        }
-        return true;
+    if (chain % 2 != 0) {
+      fprintf(stderr, "BottomToTop-mapper: Chain (--led-chain) needs to be divisible by two\n");
+      return false;
     }
-    
-    virtual void MapVisibleToMatrix(int matrix_width, int matrix_height,
-                                    int x, int y,
-                                    int *matrix_x, int *matrix_y) const {
-        const int panel_height = matrix_height / parallel_;
-        const int visible_width = (matrix_width / 64) * 32;
-        const int slab_height = 2 * panel_height;   // one folded s-shape
-        y %= slab_height;
-        if (y >= panel_height) {
-            x += visible_width;
-            y -= panel_height;
-        }
-        *matrix_x = x;
-        *matrix_y = y;
+    parallel_ = parallel;
+    return true;
+  }
+  
+  virtual bool GetSizeMapping(int matrix_width, int matrix_height,
+                              int *visible_width, int *visible_height)
+  const {
+    *visible_width = (matrix_width / 64) * 32;   // Div at 32px boundary
+    *visible_height = 2 * matrix_height;
+    if (matrix_height % parallel_ != 0) {
+      fprintf(stderr, "%s For parallel=%d we would expect the height=%d "
+              "to be divisible by %d ??\n",
+              GetName(), parallel_, matrix_height, parallel_);
+      return false;
     }
-    
+    return true;
+  }
+  
+  virtual void MapVisibleToMatrix(int matrix_width, int matrix_height,
+                                  int x, int y,
+                                  int *matrix_x, int *matrix_y) const {
+    const int panel_height = matrix_height / parallel_;
+    const int visible_width = (matrix_width / 64) * 32;
+    const int slab_height = 2 * panel_height;   // one folded s-shape
+    y %= slab_height;
+    if (y >= panel_height) {
+      x += visible_width;
+      y -= panel_height;
+    }
+    *matrix_x = x;
+    *matrix_y = y;
+  }
+  
 private:
-    int parallel_;
+  int parallel_;
 };
-
+  
 typedef std::map<std::string, PixelMapper*> MapperByName;
 static void RegisterPixelMapperInternal(MapperByName *registry,
                                         PixelMapper *mapper) {
